---
source: src/main.rs
expression: compiled
input_file: test-data/lua5.3-tests/literals.lua
---
print('testing scanner');
local debug = require("debug")
local fn dostring(x) {
    return assert(load(x), "")()
}
dostring("x \v\f = \t\r 'a\0a' \v\f\f");
assert(x == 'a\0a' && string.len(x) == 3);
assert('\n\"\'\\' == `

"'\`);
assert(string.find("\a\b\f\n\r\t\v", "^%c%c%c%c%c%c%c$"));
assert("\09912" == 'c12');
assert("\99ab" == 'cab');
assert("\099" == '\99');
assert("\099\n" == 'c\10');
assert('\0\0\0alo' == '\0' .. '\0\0' .. 'alo');
assert(010 .. 020 ..  - 030 == "1020-30");
assert("\x00\x05\x10\x1f\x3C\xfF\xe8" == "\0\5\16\31\60\255\232");
local fn lexstring(x, y, n) {
    local f = assert(load('return ' .. x .. ', require"debug".getinfo(1).currentline', ''))
    local s, l = f()
    assert(s == y && l == n);
}
lexstring("'abc\\z  \n   efg'", "abcefg", 2);
lexstring("'abc\\z  \n\n\n'", "abc", 4);
lexstring("'\\z  \n\t\f\v\n'", "", 3);
lexstring("[[\nalo\nalo\n\n]]", "alo\nalo\n\n", 5);
lexstring("[[\nalo\ralo\n\n]]", "alo\nalo\n\n", 5);
lexstring("[[\nalo\ralo\r\n]]", "alo\nalo\n", 4);
lexstring("[[\ralo\n\ralo\r\n]]", "alo\nalo\n", 4);
lexstring("[[alo]\n]alo]]", "alo]\n]alo", 2);
assert("abc\z
        def\z
        ghi\z
       " == 'abcdefghi');
assert("\u{0}\u{00000000}\x00\0" == string.char(0, 0, 0, 0));
assert("\u{0}\u{7F}" == "\x00\z\x7F");
assert("\u{80}\u{7FF}" == "\xC2\x80\z\xDF\xBF");
assert("\u{800}\u{FFFF}" == "\xE0\xA0\x80\z\xEF\xBF\xBF");
assert("\u{10000}\u{10FFFF}" == "\xF0\x90\x80\x80\z\xF4\x8F\xBF\xBF");
local fn lexerror(s, err) {
    local st, msg = load('return ' .. s, '')
    if err ~= '<eof>' {
        err = err .. "'"
    }
    assert(!st && string.find(msg, "near .-" .. err));
}
lexerror(`"abc\x"`, `\x"`);
lexerror(`"abc\x`, `\x`);
lexerror(`"\x`, `\x`);
lexerror(`"\x5"`, `\x5"`);
lexerror(`"\x5`, `\x5`);
lexerror(`"\xr"`, `\xr`);
lexerror(`"\xr`, `\xr`);
lexerror(`"\x.`, `\x.`);
lexerror(`"\x8%"`, `\x8%%`);
lexerror(`"\xAG`, `\xAG`);
lexerror(`"\g"`, `\g`);
lexerror(`"\g`, `\g`);
lexerror(`"\."`, `\%.`);
lexerror(`"\999"`, `\999"`);
lexerror(`"xyz\300"`, `\300"`);
lexerror(`"   \256"`, `\256"`);
lexerror(`"abc\u{110000}"`, `abc\u{110000`);
lexerror(`"abc\u11r"`, `abc\u1`);
lexerror(`"abc\u"`, `abc\u"`);
lexerror(`"abc\u{11r"`, `abc\u{11r`);
lexerror(`"abc\u{11"`, `abc\u{11"`);
lexerror(`"abc\u{11`, `abc\u{11`);
lexerror(`"abc\u{r"`, `abc\u{r`);
lexerror("[=[alo]]", "<eof>");
lexerror("[=[alo]=", "<eof>");
lexerror("[=[alo]", "<eof>");
lexerror("'alo", "<eof>");
lexerror("'alo \\z  \n\n", "<eof>");
lexerror("'alo \\z", "<eof>");
lexerror(`'alo \98`, "<eof>");
for i = 0, 255 {
    local s = string.char(i)
    assert(!string.find(s, "[a-zA-Z_]") == !load(s .. "=1", ""));
    assert(!string.find(s, "[a-zA-Z_0-9]") == !load("a" .. s .. "1 = 1", ""));
}
var1 = string.rep('a', 15000) .. '1'
var2 = string.rep('a', 15000) .. '2'
prog = string.format(`
  %s = 5
  %s = %s + 1
  return function () return %s - %s end
`, var1, var2, var1, var1, var2)
local f = dostring(prog)
assert(_G[(var1)] == 5 && _G[(var2)] == 6 && f() ==  - 1);
var1, var2, f = nil
print('+');
assert("\n\t" == `

	`);
assert(`

 $debug` == "\n $debug");
assert(` [ ` ~= ` ] `);
b = "001234567890123456789012345678901234567891234567890123456789012345678901234567890012345678901234567890123456789012345678912345678901234567890123456789012345678900123456789012345678901234567890123456789123456789012345678901234567890123456789001234567890123456789012345678901234567891234567890123456789012345678901234567890012345678901234567890123456789012345678912345678901234567890123456789012345678900123456789012345678901234567890123456789123456789012345678901234567890123456789001234567890123456789012345678901234567891234567890123456789012345678901234567890012345678901234567890123456789012345678912345678901234567890123456789012345678900123456789012345678901234567890123456789123456789012345678901234567890123456789001234567890123456789012345678901234567891234567890123456789012345678901234567890012345678901234567890123456789012345678912345678901234567890123456789012345678900123456789012345678901234567890123456789123456789012345678901234567890123456789"
assert(string.len(b) == 960);
prog = `
print('+')

a1 = [["this is a 'string' with several 'quotes'"]]
a2 = "'quotes'"

assert(string.find(a1, a2) == 34)
print('+')

a1 = [==[temp = [[an arbitrary value]]; ]==]
assert(load(a1))()
assert(temp == 'an arbitrary value')
-- long strings --
b = "001234567890123456789012345678901234567891234567890123456789012345678901234567890012345678901234567890123456789012345678912345678901234567890123456789012345678900123456789012345678901234567890123456789123456789012345678901234567890123456789001234567890123456789012345678901234567891234567890123456789012345678901234567890012345678901234567890123456789012345678912345678901234567890123456789012345678900123456789012345678901234567890123456789123456789012345678901234567890123456789001234567890123456789012345678901234567891234567890123456789012345678901234567890012345678901234567890123456789012345678912345678901234567890123456789012345678900123456789012345678901234567890123456789123456789012345678901234567890123456789001234567890123456789012345678901234567891234567890123456789012345678901234567890012345678901234567890123456789012345678912345678901234567890123456789012345678900123456789012345678901234567890123456789123456789012345678901234567890123456789"
assert(string.len(b) == 960)
print('+')

a = [[00123456789012345678901234567890123456789123456789012345678901234567890123456789
00123456789012345678901234567890123456789123456789012345678901234567890123456789
00123456789012345678901234567890123456789123456789012345678901234567890123456789
00123456789012345678901234567890123456789123456789012345678901234567890123456789
00123456789012345678901234567890123456789123456789012345678901234567890123456789
00123456789012345678901234567890123456789123456789012345678901234567890123456789
00123456789012345678901234567890123456789123456789012345678901234567890123456789
00123456789012345678901234567890123456789123456789012345678901234567890123456789
00123456789012345678901234567890123456789123456789012345678901234567890123456789
00123456789012345678901234567890123456789123456789012345678901234567890123456789
00123456789012345678901234567890123456789123456789012345678901234567890123456789
00123456789012345678901234567890123456789123456789012345678901234567890123456789
00123456789012345678901234567890123456789123456789012345678901234567890123456789
00123456789012345678901234567890123456789123456789012345678901234567890123456789
00123456789012345678901234567890123456789123456789012345678901234567890123456789
00123456789012345678901234567890123456789123456789012345678901234567890123456789
00123456789012345678901234567890123456789123456789012345678901234567890123456789
00123456789012345678901234567890123456789123456789012345678901234567890123456789
00123456789012345678901234567890123456789123456789012345678901234567890123456789
00123456789012345678901234567890123456789123456789012345678901234567890123456789
00123456789012345678901234567890123456789123456789012345678901234567890123456789
00123456789012345678901234567890123456789123456789012345678901234567890123456789
00123456789012345678901234567890123456789123456789012345678901234567890123456789
]]
assert(string.len(a) == 1863)
assert(string.sub(a, 1, 40) == string.sub(b, 1, 40))
x = 1
`
print('+');
x = nil
dostring(prog);
assert(x);
prog = nil
a = nil
b = nil
prog = `
a = 1        -- a comment
b = 2


x = [=[
hi
]=]
y = "\
hello\r\n\
"
return require"debug".getinfo(1).currentline
`
for _, n with pairs({
    "\n", 
    "\r", 
    "\n\r", 
    "\r\n"
}) {
    local prog, nn = string.gsub(prog, "\n", n)
    assert(dostring(prog) == nn);
    assert(_G.x == "hi\n" && _G.y == "\nhello\r\n\n");
}
a = `]=`
assert(a == "]=");
a = `[===[[=[]]=][====[]]===]===`
assert(a == "[===[[=[]]=][====[]]===]===");
a = `[===[[=[]]=][====[]]===]===`
assert(a == "[===[[=[]]=][====[]]===]===");
a = `]]]]]]]]`
assert(a == "]]]]]]]]");
local x = {
    "=", 
    "[", 
    "]", 
    "\n"
}
local len = 4
local fn gen(c, n) {
    if n == 0 {
        coroutine.yield(c);
    } else {
        for _, a with pairs(x) {
            gen(c .. a, n - 1);
        }
    }
}
for s with coroutine.wrap(fn () {
    gen("", len);
}) {
    assert(s == load("return [====[\n" .. s .. "]====]", "")());
}
if os.setlocale("pt_BR") || os.setlocale("ptb") {
    assert(tonumber("3,4") == 3.4 && tonumber("3.4") == 3.4);
    assert(tonumber("  -.4  ") ==  - 0.4);
    assert(tonumber("  +0x.41  ") == 0.25390625);
    assert(!load("a = (3,4)"));
    assert(assert(load("return 3.4"))() == 3.4);
    assert(assert(load("return .4,3"))() == 0.4);
    assert(assert(load("return 4."))() == 4.0);
    assert(assert(load("return 4.+.5"))() == 4.5);
    assert(" 0x.1 " + " 0x,1" + "-0X.1\t" == 0.0625);
    assert(tonumber("inf") == nil && tonumber("NAN") == nil);
    assert(assert(load(string.format("return %q", 4.51)))() == 4.51);
    local a, b = load("return 4.5.")
    assert(string.find(b, "'4%.5%.'"));
    assert(os.setlocale("C"));
} else {
    (Message || print)('\n >>> pt_BR locale not available: skipping decimal point tests <<<\n');
}
local s = "a string with \r and \n and \r\n and \n\r"
local c = string.format("return %q", s)
assert(assert(load(c))() == s);
assert(!load("a = 'non-ending string"));
assert(!load("a = 'non-ending string\n'"));
assert(!load("a = '\\345'"));
assert(!load("a = [=x]"));
print('OK');
